From c5c199fe26e07e13f5dafdd5ab5a3e5fc399ada6 Mon Sep 17 00:00:00 2001
From: Jevgenijs Protopopovs <jevgenijs.protopopovs@inria.fr>
Date: Mon, 24 Jun 2024 09:02:46 +0200
Subject: [PATCH 4/5] Implement correct lowering of memref.store with i4
 element type to llvm

---
 .../Conversion/MemRefToLLVM/MemRefToLLVM.cpp  | 77 ++++++++++++++++++-
 1 file changed, 76 insertions(+), 1 deletion(-)

diff --git a/mlir/lib/Conversion/MemRefToLLVM/MemRefToLLVM.cpp b/mlir/lib/Conversion/MemRefToLLVM/MemRefToLLVM.cpp
index 1195f0674c9a..73f96362925d 100644
--- a/mlir/lib/Conversion/MemRefToLLVM/MemRefToLLVM.cpp
+++ b/mlir/lib/Conversion/MemRefToLLVM/MemRefToLLVM.cpp
@@ -915,7 +915,7 @@ struct LoadOpLowering : public LoadStoreOpLowering<memref::LoadOp> {
               index ? rewriter.create<LLVM::AddOp>(loc, index, increment) : increment;
         }
 
-        Value position, offset;
+        Value position;
         Value one_const = rewriter.create<LLVM::ConstantOp>(loc, indexType, 1);
         Value two_const = rewriter.create<LLVM::ConstantOp>(loc, indexType, 2);
         if (index) {
@@ -973,6 +973,81 @@ struct StoreOpLowering : public LoadStoreOpLowering<memref::StoreOp> {
   matchAndRewrite(memref::StoreOp op, OpAdaptor adaptor,
                   ConversionPatternRewriter &rewriter) const override {
     auto type = op.getMemRefType();
+    auto elementType = type.getElementType();
+
+    if (auto integralElementType = dyn_cast<IntegerType>(elementType)) {
+      if (integralElementType.getWidth() == 4) {
+        auto loc = op.getLoc();
+        MemRefDescriptor memRefDescriptor(adaptor.getMemref());
+        Type indexType = getIndexType();
+        auto indices = adaptor.getIndices();
+
+        auto [strides, offsetCst] = type.getStridesAndOffset();
+        Value base = memRefDescriptor.alignedPtr(rewriter, loc);
+        Value index;
+        if (offsetCst != 0) {
+          Type indexType = getTypeConverter()->getIndexType();
+          index =
+              ShapedType::isDynamic(offsetCst)
+                  ? memRefDescriptor.offset(rewriter, loc)
+                  : createIndexAttrConstant(rewriter, loc, indexType, offsetCst);
+        }
+
+        // Value index;
+        for (int i = 0, e = indices.size(); i < e; ++i) {
+          Value increment = indices[i];
+          if (strides[i] != 1) { // Skip if stride is 1.
+            Value stride =
+                ShapedType::isDynamic(strides[i])
+                    ? memRefDescriptor.stride(rewriter, loc, i)
+                    : createIndexAttrConstant(rewriter, loc, indexType, strides[i]);
+            increment = rewriter.create<LLVM::MulOp>(loc, increment, stride);
+          }
+          index =
+              index ? rewriter.create<LLVM::AddOp>(loc, index, increment) : increment;
+        }
+
+        Value position;
+        Value one_const = rewriter.create<LLVM::ConstantOp>(loc, indexType, 1);
+        Value two_const = rewriter.create<LLVM::ConstantOp>(loc, indexType, 2);
+        if (index) {
+          position = rewriter.create<LLVM::LShrOp>(loc, index, one_const);
+        }
+
+        Type elementPtrType = memRefDescriptor.getElementPtrType();
+        Value pointer = position ? rewriter.create<LLVM::GEPOp>(
+                          loc, elementPtrType,
+                          getTypeConverter()->convertType(type.getElementType()),
+                          base, position)
+                    : base;
+
+        Value currentValue = rewriter.create<LLVM::LoadOp>(
+            loc, typeConverter->convertType(rewriter.getI8Type()), pointer, 0,
+            false, op.getNontemporal());
+
+        Value mask = rewriter.create<LLVM::ConstantOp>(loc, rewriter.getI8Type(), 0xf);
+        Value insertedValue = rewriter.create<LLVM::ZExtOp>(loc, rewriter.getI8Type(), adaptor.getValue());
+        insertedValue = rewriter.create<LLVM::AndOp>(loc, insertedValue, mask);
+        if (index) {
+          Value offset = rewriter.create<LLVM::AndOp>(loc, index, one_const);
+          offset = rewriter.create<LLVM::ShlOp>(loc, offset, two_const);
+          offset = rewriter.create<LLVM::TruncOp>(loc, rewriter.getI8Type(), offset);
+          mask = rewriter.create<LLVM::ShlOp>(loc, mask, offset);
+          insertedValue = rewriter.create<LLVM::ShlOp>(loc, insertedValue, offset);
+        }
+        Value minus_one_const = rewriter.create<LLVM::ConstantOp>(loc, rewriter.getI8Type(), -1);
+        mask = rewriter.create<LLVM::XOrOp>(loc, mask, minus_one_const);
+
+        Value maskedCurrentValue = rewriter.create<LLVM::AndOp>(loc, currentValue, mask);
+        Value newValue = rewriter.create<LLVM::OrOp>(loc, maskedCurrentValue, insertedValue);
+
+        rewriter.replaceOpWithNewOp<LLVM::StoreOp>(op, newValue, pointer,
+                                                  0, false, op.getNontemporal());
+        return success();
+      } else {
+        assert(integralElementType.getWidth() >= 8);
+      }
+    }
 
     // Per memref.store spec, the indices must be in-bounds:
     // 0 <= idx < dim_size, and additionally all offsets are non-negative,
-- 
2.34.1

